''' Module for setting up and handling argument parsers
'''

import argparse
import glob
from os.path import basename, join
import pkg_resources

def _setup_new_parser(subparsers):
    '''_setup_new_parser

    Setup parser for the ginjinn new subcommand.

    Parameters
    ----------
    subparsers
        An object returned by argparse.ArgumentParser.add_subparsers()

    Returns
    -------
    parser
        An argparse ArgumentParser, registered for the new subcommand.
    '''

    parser = subparsers.add_parser(
        'new',
        help = '''Create a new GinJinn project.''',
        description = '''Create a new GinJinn project.''',
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False,
    )
    parser.add_argument(
        'project_dir',
        type = str,
        help = '''GinJinn project directory to be created.'''
    )

    required = parser.add_argument_group('required arguments')

    template_dir =  pkg_resources.resource_filename(
        'ginjinn', 'data/ginjinn_config/templates',
    )
    template_files = glob.glob(join(template_dir, '*.yaml'))
    templates = sorted([basename(t_f) for t_f in template_files])
    templates = [t for t in templates if not t.startswith('adv_')]
    templates_string = '\n'.join(f'- {t}' for t in templates)
    required.add_argument(
        '-t', '--template',
        type = str,
        help = f'''Model template, specifying the Detectron2 model to use.
Faster RCNN models are used for bounding-box detection, while
Mask RCNN models are used for instance segmentation. Please do not
exchange the model after project initialization.

Available templates are:
{templates_string}

(default: "faster_rcnn_R_50_FPN_3x.yaml")''',
        choices=templates,
        # default='faster_rcnn_R_50_FPN_3x.yaml',
        required=True,
        metavar='TEMPLATE'
    )

    optional = parser.add_argument_group('optional arguments')

    optional.add_argument(
        '-d', '--data_dir',
        type=str,
        default=None,
        help='''Data directory to initialize the project config for. Can either be the path
to a single COCO/PVOC dataset directory, or a directory comprising multiple datasets
as generated by "ginjinn split".'''
    )

    optional.add_argument(
        '-a', '--advanced',
        dest='advanced',
        action='store_true',
        help='Expose advanced options in the GinJinn configuration file.'
    )
    parser.set_defaults(advanced=False)

    optional.add_argument('-h', '--help', action='help', help='Show this help message and exit.')

    return parser

def _setup_train_parser(subparsers):
    '''_setup_train_parser

    Setup parser for the ginjinn train subcommand.

    Parameters
    ----------
    subparsers
        An object returned by argparse.ArgumentParser.add_subparsers()

    Returns
    -------
    parser
        An argparse ArgumentParser, registered for the train subcommand.
    '''

    parser = subparsers.add_parser(
        'train',
        help = '''
            Train an object detection model.
        ''',
        description = '''
            Train an object detection model.
        ''',
        add_help=False,
    )
    parser.add_argument(
        'project_dir',
        type = str,
        help = '''
            GinJinn project directory.
        '''
    )

    parser.add_argument(
        '-n', '--n_iter',
        type = int,
        help = 'Number of iterations. Overrides the number of iterations given in ginjinn_config.yaml.',
        default = None,
    )

    parser.add_argument(
        '-r',
        '--resume',
        dest='resume',
        action='store_true',
        help='Resume Training. Overrides the resume option given in ginjinn_config.yaml.'
    )
    parser.add_argument(
        '-x',
        '--no-resume',
        dest='resume',
        action='store_false',
        help='''
            Restart training. Overrides the resume option given in ginjinn_config.yaml.
            ATTENTION: This will discard previous training progress!
        '''
    )
    parser.set_defaults(resume=None)

    parser.add_argument(
        '-f', '--force',
        dest='force',
        action='store_true',
        help='Enforce removal of existing outputs when resume is set to False.'
    )
    parser.set_defaults(force=False)

    parser.add_argument('-h', '--help', action='help', help='Show this help message and exit.')

    return parser

def _setup_evaluate_parser(subparsers):
    '''_setup_evaluate_parser

    Setup parser for the ginjinn evaluate subcommand.

    Parameters
    ----------
    subparsers
        An object returned by argparse.ArgumentParser.add_subparsers()

    Returns
    -------
    parser
        An argparse ArgumentParser, registered for the evaluate subcommand.
    '''

    parser = subparsers.add_parser(
        'evaluate',
        aliases=['eval'],
        help='''
            Evaluate a trained object detection model.
            This calculates COCO evaluation metrics (see https://cocodataset.org/#detection-eval) for the test dataset and stores the results
            in a CSV file.
        ''',
        description='''
            Evaluate a trained object detection model.
            This calculates COCO evaluation metrics (see https://cocodataset.org/#detection-eval) for the test dataset and stores the results
            in a CSV file.
        ''',
        add_help=False,
        epilog='''
            Example usage:

            ginjinn evaluate my_analysis
        ''',
        # formatter_class=SmartFormatter,
    )
    parser.add_argument(
        'project_dir',
        type = str,
        help = '''
            Path to GinJinn project directory.
        '''
    )

    optional = parser.add_argument_group('optional arguments')
    optional.add_argument(
        '-c', '--checkpoint',
        type = str,
        help = '''
            Checkpoint name. By default model_final.pth will be used.
        ''',
        default = "model_final.pth",
    )
    optional.add_argument('-h', '--help', action='help', help='Show this help message and exit.')

    return parser

def _setup_predict_parser(subparsers):
    '''_setup_predict_parser

    Setup parser for the ginjinn predict subcommand.

    Parameters
    ----------
    subparsers
        An object returned by argparse.ArgumentParser.add_subparsers()

    Returns
    -------
    parser
        An argparse ArgumentParser, registered for the predict subcommand.
    '''

    parser = subparsers.add_parser(
        'predict',
        help = '''
            Predict from a trained object detection model.
        ''',
        description = '''
            Predict from a trained object detection model.
        ''',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        add_help=False,
    )
    parser.add_argument(
        'project_dir',
        type = str,
        help = '''
            Path to GinJinn project directory.
        '''
    )

    # Required
    required = parser.add_argument_group('required arguments')
    required.add_argument(
        '-i', '--image_path',
        type = str,
        help = '''
            Either path to an image directory or to a single image.
        ''',
        required=True,
    )

    # TODO: refactor this!!!
    # - always return COCO
    # - optionally cropped and vis
    required.add_argument(
        '-s', '--output_types',
        help = '''
            Output types.
        ''',
        choices=['COCO', 'cropped', 'visualization'],
        nargs='+',
        action='append',
        default=['COCO'],
    )

    # Optional
    optional = parser.add_argument_group('optional arguments')
    optional.add_argument(
        '-o', '--out_dir',
        type = str,
        help = '''
            Output directory. By default, output will be written to
            "<project_dir>/prediction".
        ''',
        default = None,
    )

    optional.add_argument(
        '-c', '--checkpoint',
        type = str,
        help = '''
            Checkpoint name. By default model_final.pth will be used.
        ''',
        default = "model_final.pth",
    )

    optional.add_argument(
        '-t', '--threshold',
        type = float,
        help = '''
            Prediction threshold. Only predictions with confidence scores >= threshold are saved.
        ''',
        default = 0.8
    )

    optional.add_argument(
        '-p', '--padding',
        type = int,
        help = '''
            Padding for cropping bounding boxes in pixels.
            Only relevant if cropped output option is enabled.
        ''',
        default = 0
    )

    optional.add_argument(
        '-r', '--seg_refinement',
        dest = 'seg_refinement',
        action = 'store_true',
        help = '''
            Apply segmentation refinement using CascadePSP (https://arxiv.org/abs/2005.02551).
        '''
    )
    parser.set_defaults(seg_refinement = False)

    optional.add_argument(
        '-m', '--refinement_mode',
        help = '''
            Refinement mode. Either "fast" or "full".
        ''',
        choices=['fast', 'full'],
        default='full',
    )

    optional.add_argument(
        '-d', '--device',
        help = '''
            Hardware device to be used for segmentation refinement.
            Since CascadePSP is computationally intensive, it is highly recommended
            to use a GPU device. By default the first available GPU will be used.
        ''',
        type=str,
        default='cuda:0',
    )

    optional.add_argument('-h', '--help', action='help', help='Show this help message and exit.')

    return parser

def _setup_split_parser(subparsers):
    '''_setup_split_parser

    Setup parser for the ginjinn split subcommand.

    Parameters
    ----------
    subparsers
        An object returned by argparse.ArgumentParser.add_subparsers()

    Returns
    -------
    parser
        An argparse ArgumentParser, registered for the split subcommand.
    '''

    parser = subparsers.add_parser(
        'split',
        help = '''
            Split a single dataset (images and annotations) into train, and optionally
            validation and test datasets.
        ''',
        description = '''
            Split a single dataset (images and annotations) into train, and optionally
            validation and test datasets.
        ''',
        add_help=False,
    )
    required = parser.add_argument_group('required arguments')
    required.add_argument(
        '-a', '--annotation_path',
        type = str,
        help = '''
            Path to directory containing annotations (PVOC) or path to an annotation
            JSON file (COCO).
        ''',
        required = True,
    )
    required.add_argument(
        '-o', '--output_dir',
        type = str,
        help = '''
            Output directory. Sub-datasets will be written to OUTPUT_DIR/train,
            OUTPUT_DIR/val or OUTPUT_DIR/test. The output directory
            will be newly created, if it does not exist. 
        ''',
        required = True,
    )
    required.add_argument(
        '-d', '--task',
        type = str,
        choices = [
            'instance-segmentation', 'bbox-detection'
        ],
        help = '''
            Task, which the dataset will be used for.
        ''',
        required = True,
    )
    optional = parser.add_argument_group('optional arguments')
    optional.add_argument(
        '-i', '--img_dir',
        type = str,
        help = '''
            Directory containing the annotated images.
            By default, images are expected to be found in a sister directory of ANN_PATH.
        ''',
        default=None,
    )
    optional.add_argument(
        '-k', '--ann_type',
        type = str,
        choices = ['auto', 'COCO', 'PVOC'],
        help = '''
            Annotation type. Will be inferred if set to 'auto'.
        ''',
        default='auto',
    )
    optional.add_argument(
        '-t', '--test_proportion',
        type = float,
        help = '''
            Proportion of the dataset to reserve for final model evaluation (ginjinn evaluate).
        ''',
        default = 0.2,
    )
    optional.add_argument(
        '-v', '--validation_proportion',
        type = float,
        help = '''
            Proportion of the dataset to use for validation while training.
        ''',
        default = 0.2,
    )
    optional.add_argument('-h', '--help', action='help', help='Show this help message and exit.')

    return parser

def _setup_info_parser(subparsers):
    '''_setup_info_parser

    Setup parser for the ginjinn info subcommand.

    Parameters
    ----------
    subparsers
        An object returned by argparse.ArgumentParser.add_subparsers()

    Returns
    -------
    parser
        An argparse ArgumentParser, registered for the info subcommand.
    '''

    info_parser = subparsers.add_parser(
        'info',
        help = '''
            Summarize basic information about a dataset (number of images, objects per category).
        ''',
        description = '''
            Summarize basic information about a dataset (number of images, objects per category).
        ''',
        add_help=False,
    )

    # required
    info_parser_required = info_parser.add_argument_group('required arguments')
    info_parser_required.add_argument(
        '-a', '--ann_path',
        type = str,
        help = '''
            Path to COCO annotation file (JSON) or directory containing PVOC annotations.
        ''',
        required=True,
    )
    info_parser_optional = info_parser.add_argument_group('optional arguments')
    info_parser_optional.add_argument(
        '-i', '--img_dir',
        type = str,
        help = '''
            Directory containing the annotated images. By default, images are expected to be found in a sister directory
            of ANN_PATH.
        ''',
        default = None,
    )
    info_parser_optional.add_argument(
        '-t', '--ann_type',
        type = str,
        help = '''
            Annotation type. Will be inferred if set to 'auto'.
        ''',
        choices = ['auto', 'COCO', 'PVOC'],
        default = 'auto'
    )
    info_parser_optional.add_argument('-h', '--help', action='help', help='Show this help message and exit.')

    return info_parser

def _setup_simulate_parser(subparsers):
    '''_setup_simulate_parser

    Setup parser for the ginjinn simulate subcommand.

    Parameters
    ----------
    subparsers
        An object returned by argparse.ArgumentParser.add_subparsers()

    Returns
    -------
    parser
        An argparse ArgumentParser, registered for the simulate subcommand.
    '''

    parser = subparsers.add_parser(
        'simulate',
        help = '''
            Create simulated datasets.
        ''',
        description = '''
            Create simulated datasets.
        ''',
    )
    simulate_parsers = parser.add_subparsers(
        dest='simulate_subcommand',
        help='Types of simulations.'
    )

    # == shapes
    shapes_parser = simulate_parsers.add_parser(
        'shapes',
        help = '''
            Simulate a simple segmentation dataset with COCO annotations,
            or a simple bounding-box dataset with PVOC annotations,
            containing two classes: circles and triangles.
        ''',
        description = '''
            Simulate a simple segmentation dataset with COCO annotations,
            or a simple bounding-box dataset with PVOC annotations,
            containing two classes: circles and triangles.
        ''',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        add_help=False,
    )
    required = shapes_parser.add_argument_group('required arguments')
    required.add_argument(
        '-o', '--out_dir',
        type = str,
        help = '''
            Path to directory, which the simulated data should be written to.
        ''',
        required=True,
    )

    optional = shapes_parser.add_argument_group('optional arguments')
    optional.add_argument(
        '-a', '--ann_type',
        type = str,
        help = '''
            Type of annotations to simulate.
        ''',
        choices=['COCO', 'PVOC'],
        default='COCO',
    )
    optional.add_argument(
        '-n', '--n_images',
        type = int,
        help = '''
            Number of images to simulate.
        ''',
        default=100,
    )
    optional.add_argument(
        '-w0', '--min_w',
        type = int,
        help = '''
            Minimum image width.
        ''',
        default=400,
    )
    optional.add_argument(
        '-w1', '--max_w',
        type = int,
        help = '''
            Maximum image width.
        ''',
        default=400,
    )
    optional.add_argument(
        '-h0', '--min_h',
        type = int,
        help = '''
            Minimum image height.
        ''',
        default=400,
    )
    optional.add_argument(
        '-h1', '--max_h',
        type = int,
        help = '''
            Maximum image height.
        ''',
        default=400,
    )
    optional.add_argument(
        '-n0', '--min_n_shapes',
        type = int,
        help = '''
            Minimum number of shapes per image.
        ''',
        default=1,
    )
    optional.add_argument(
        '-n1', '--max_n_shapes',
        type = int,
        help = '''
            Maximum number of shapes per image.
        ''',
        default=4,
    )
    optional.add_argument(
        '-t', '--triangle_prob',
        type = float,
        help = '''
            Probability of generating a triangle. Default is 0.5, meaning that
            triangles and circle are equally represented.
        ''',
        default=0.5,
    )
    optional.add_argument(
        '-ccol', '--circle_col',
        type = str,
        help = '''
            Mean circle color as Hex color code.
        ''',
        default='#C87D7D',
    )
    optional.add_argument(
        '-tcol', '--triangle_col',
        type = str,
        help = '''
            Mean triangle color as Hex color code.
        ''',
        default='#7DC87D',
    )
    optional.add_argument(
        '-cvar', '--color_variance',
        type = float,
        help = '''
            Variance around mean shape colors.
        ''',
        default=0.15,
    )
    optional.add_argument(
        '-mnr', '--min_shape_radius',
        type = float,
        help = '''
            Minimum shape radius.
        ''',
        default=25.0,
    )
    optional.add_argument(
        '-mxr', '--max_shape_radius',
        type = float,
        help = '''
            Maximum shape radius.
        ''',
        default=75.0,
    )
    optional.add_argument(
        '-mna', '--min_shape_angle',
        type = float,
        help = '''
            Minimum shape rotation in degrees.
        ''',
        default=0.0,
    )
    optional.add_argument(
        '-mxa', '--max_shape_angle',
        type = float,
        help = '''
            Maximum shape rotation in degrees.
        ''',
        default=60.0,
    )
    optional.add_argument(
        '-b', '--noise',
        type = float,
        help = '''
            Amount of noise to add.
        ''',
        default=0.005,
    )
    optional.add_argument('-h', '--help', action='help', help='Show this help message and exit.')

    # ==
    # ... further simulations ...
    # ==

    return parser

def _setup_utils_parser(subparsers):
    '''_setup_utils_parser

    Setup parser for the ginjinn utils subcommand.

    Parameters
    ----------
    subparsers
        An object returned by argparse.ArgumentParser.add_subparsers()

    Returns
    -------
    parser
        An argparse ArgumentParser, registered for the utils subcommand.
    '''

    parser = subparsers.add_parser(
        'utils',
        help = '''
            Auxiliary commands, mainly for data pre- and postprocessing.
        ''',
        description = '''
            Auxiliary commands, mainly for data pre- and postprocessing.
        ''',
    )

    utils_parsers = parser.add_subparsers(
        dest='utils_subcommand',
    )
    utils_parsers.required = True

    # # == cleanup
    # cleanup_parser = utils_parsers.add_parser(
    #     'cleanup',
    #     help = '''
    #         Cleanup GinJinn project directory, removing the outputs directory and evaluation an training results.
    #     ''',
    #     description = '''
    #         Cleanup GinJinn project directory, removing the outputs directory and evaluation an training results.
    #     ''',
    #     formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    # )

    # cleanup_parser.add_argument(
    #     'project_dir',
    #     type = str,
    #     help = '''
    #         GinJinn project directory to be cleaned up.
    #     ''',
    # )

    # == count
    count_parser = utils_parsers.add_parser(
        'count',
        help = '''
            Count objects per category for each image.
        ''',
        description = '''
            Count objects per category for each image.
        ''',
        add_help=False,
    )

    # required
    count_parser_required = count_parser.add_argument_group('required arguments')
    count_parser_required.add_argument(
        '-a', '--ann_path',
        type = str,
        help = '''
            Path to COCO annotation file (JSON).
        ''',
        required=True,
    )
    count_parser_required.add_argument(
        '-o', '--out_file',
        type = str,
        help = '''
            File (CSV) the category counts should be written to.
        ''',
        required=True,
    )

    count_parser_optional = count_parser.add_argument_group('optional arguments')
    count_parser_optional.add_argument('-h', '--help', action='help', help='Show this help message and exit.')

    # == crop
    crop_parser = utils_parsers.add_parser(
        'crop',
        help = '''
            Crop bounding boxes found in a COCO dataset as single images.
            This can be useful for multi-step pipelines, e.g. training a bounding box model
            based on the original images, and a segmentation model using the cropped bounding
            boxes.
        ''',
        description = '''
            Crop bounding boxes found in a COCO dataset as single images.
            This can be useful for multi-step pipelines, e.g. training a bounding box model
            based on the original images, and a segmentation model using the cropped bounding
            boxes.
        ''',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        add_help=False,
    )

    # required
    crop_required = crop_parser.add_argument_group('required arguments')

    crop_required.add_argument(
        '-o', '--out_dir',
        type = str,
        help = '''
            Output directory.
        ''',
        required=True,
    )
    crop_required.add_argument(
        '-a', '--ann_path',
        type = str,
        help = '''
            COCO (JSON) annotation file.
        ''',
        required=True,
    )
    crop_required.add_argument(
        '-t', '--type',
        type=str,
        help='''
            Cropping type. When "segmentation" is selected,
            only bounding boxes with a corresponding segmentation will be cropped.
        ''',
        choices=['segmentation', 'bbox'],
        required=True,
    )

    # optional
    crop_optional = crop_parser.add_argument_group('optional arguments')
    crop_optional.add_argument(
        '-i', '--img_dir',
        type = str,
        help = '''
            Directory containing the annotated images. By default, images are expected to be found in a sister directory
            of ANN_PATH.
        ''',
        default=None,
    )
    crop_optional.add_argument(
        '-p', '--padding',
        type = int,
        help = '''
            Padding for cropping bounding boxes in pixels.
        ''',
        default=5,
    )
    crop_optional.add_argument('-h', '--help', action='help', help='Show this help message and exit.')

    # == filter_cat
    filter_cat_parser = utils_parsers.add_parser(
        'filter_cat',
        help = '''
            Filter objects by category.
        ''',
        description = '''
            Filter objects by category.
            ATTENTION: By default, only a new annotation file will be created.
            If you are interested in creating a new filtered dataset, provide an image directory
            using -i/--img_dir.
        ''',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        add_help=False,
    )

    # required
    filter_cat_parser_required = filter_cat_parser.add_argument_group('required arguments')
    filter_cat_parser_required.add_argument(
        '-o', '--out_dir',
        type = str,
        help = '''
            Output directory, to which the filtered annotations, and optionally filtered images
            (see img_dir option) will be written.
        ''',
        required=True,
    )
    filter_cat_parser_required.add_argument(
        '-a', '--ann_path',
        type = str,
        help = '''
            Path to COCO annotation file (JSON) or directory containing PVOC annotations.
        ''',
        required=True,
    )
    filter_cat_parser_required.add_argument(
        '-f', '--filter',
        type = str,
        help = '''
            Names of categories to keep.
            By default, the passed categories are kept and the remaining ones are dropped.
            The -d/--drop option can be used to invert this behavior.
        ''',
        action = 'append',
        required = True,
    )

    # optional
    filter_cat_parser_optional = filter_cat_parser.add_argument_group('optional arguments')
    filter_cat_parser_optional.add_argument(
        '-t', '--ann_type',
        type = str,
        help = '''
            Annotation type. Will be inferred if set to 'auto'.
        ''',
        choices = ['auto', 'COCO', 'PVOC'],
        default = 'auto',
    )
    filter_cat_parser_optional.add_argument(
        '-d', '--drop',
        action = 'store_true',
        help = '''
            Drop categories in filter instead of keeping them.
        '''
    )
    parser.set_defaults(drop = False)

    filter_cat_parser_optional.add_argument(
        '-i', '--img_dir',
        type = str,
        help = '''
            Directory containing the annotated images. Use this parameter if you
            want to filter out images without annotation after category filtering.
        ''',
        required=False,
        default=None,
    )
    filter_cat_parser_optional.add_argument(
        '-c', '--copy_images',
        action = 'store_true',
        help = '''
            Copy images to img_dir instead of creating hard links.
        '''
    )
    filter_cat_parser_optional.add_argument('-h', '--help', action='help', help='Show this help message and exit.')
    parser.set_defaults(copy_images = False)

    # == filter_size
    filter_size_parser = utils_parsers.add_parser(
        'filter_size',
        help = '''
            Filter objects by size.
            Note: This function is only compatible with annotations in COCO format.
        ''',
        description = '''
            Filter objects by size.
            Note: This function is only compatible with annotations in COCO format.
        ''',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        add_help=False,
    )

    # required
    filter_size_parser_required = filter_size_parser.add_argument_group('required arguments')
    filter_size_parser_required.add_argument(
        '-o', '--out_file',
        type = str,
        help = '''
            COCO annotation file (JSON), which the filtered annotations should be written to.
        ''',
        required=True,
    )
    filter_size_parser_required.add_argument(
        '-a', '--ann_file',
        type = str,
        help = '''
            Path to COCO annotation file (JSON).
        ''',
        required=True,
    )
    filter_size_parser_required.add_argument(
        '-d', '--task',
        type = str,
        choices = [
            'instance-segmentation', 'bbox-detection'
        ],
        help = '''
            Task, which the dataset will be used for.
        ''',
        required = True,
    )

    # optional
    filter_size_parser_optional = filter_size_parser.add_argument_group(
        'optional arguments'
    )
    filter_size_parser_optional.add_argument(
        '-x', '--min_width',
        type = int,
        default = 5,
        help = '''
            Minimal total object width in pixels.
        '''
    )
    filter_size_parser_optional.add_argument(
        '-y', '--min_height',
        type = int,
        default = 5,
        help = '''
            Minimal total object height in pixels.
        '''
    )
    filter_size_parser_optional.add_argument(
        '-r', '--min_area',
        type = int,
        default = 25,
        help = '''
            Minimal total object area in pixels.
        '''
    )
    filter_size_parser_optional.add_argument(
        '-f', '--min_fragment_area',
        type = int,
        default = 25,
        help = '''
            Minimal object fragment area in pixels.
            Fragments of non-contiguous objects smaller than this will be discarded.
        '''
    )
    filter_size_parser_optional.add_argument('-h', '--help', action='help', help='Show this help message and exit.')

    # == flatten
    flatten_parser = utils_parsers.add_parser(
        'flatten',
        help = '''
            Flatten a COCO dataset: move all images into a single, unnested directory, and adjust annotations accordingly.
        ''',
        description = '''
            Flatten a COCO dataset: move all images into a single, unnested directory, and adjust annotations accordingly.
        ''',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        add_help=False,
    )

    # required
    flatten_required = flatten_parser.add_argument_group('required arguments')

    flatten_required.add_argument(
        '-o', '--out_dir',
        type = str,
        help = '''
            Path to directory, which the flattened dataset will be written to.
        ''',
        required=True,
    )
    flatten_required.add_argument(
        '-i', '--image_root_dir',
        type = str,
        help = '''
            Root image directory. For COCO this is generally the "images" directory
            within the COCO dataset directory.
        ''',
        required=True,
    )
    flatten_required.add_argument(
        '-a', '--ann_path',
        type = str,
        help = '''
            Path to the COCO (JSON) annotation file.
        ''',
        required=True,
    )

    # optional
    flatten_optional = flatten_parser.add_argument_group('optional arguments')
    flatten_optional.add_argument(
        '-s', '--separator',
        type = str,
        help = '''
            The new image file names will encode the original image paths.
            The separator will replace the "/" characters in the latter.
            For example, the image file "image_root_dir/a/b/c.jpg" may result in
            "a~b~c.jpg" (unless -u/--unique_id is specified).
        ''',
        default='~',
    )
    flatten_optional.add_argument(
        '-u', '--unique_id',
        dest = 'unique_id',
        action = 'store_true',
        help = '''
            Replace image file names with an unique id. An ID mapping file
            will be written if this option is set.
        '''
    )
    parser.set_defaults(unique_id = False)

    flatten_optional.add_argument(
        '-x', '--annotated_only',
        dest = 'annotated_only',
        action = 'store_true',
        help = '''
            Keep only images with corresponding object annotations.
        '''
    )
    parser.set_defaults(annotated_only = False)

    flatten_optional.add_argument('-h', '--help', action='help', help='Show this help message and exit.')

    # == flatten_img_dir
    flatten_img_dir_parser = utils_parsers.add_parser(
        'flatten_img_dir',
        help = '''
            Flatten image directory: move all images into a single, unnested directory.
        ''',
        description = '''
            Flatten image directory: move all images into a single, unnested directory.
        ''',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        add_help=False,
    )

    # required
    flatten_img_dir_required = flatten_img_dir_parser.add_argument_group('required arguments')

    flatten_img_dir_required.add_argument(
        '-o', '--out_dir',
        type = str,
        help = '''
            Path to directory, which the images should be linked to.
        ''',
        required=True,
    )

    flatten_img_dir_required.add_argument(
        '-i', '--image_root_dir',
        type = str,
        help = '''
            Path to image directory root.
        ''',
        required=True,
    )

    # optional
    flatten_img_dir_optional = flatten_img_dir_parser.add_argument_group('optional arguments')
    flatten_img_dir_optional.add_argument(
        '-s', '--separator',
        type = str,
        help = '''
            The new image file names will encode the original image paths.
            The separator will replace the "/" characters in the latter.
            For example, the image file "image_root_dir/a/b/c.jpg" may result in
            "a~b~c.jpg" (unless -u/--unique_id is specified).
        ''',
        default='~',
    )
    flatten_img_dir_optional.add_argument(
        '-u', '--unique_id',
        dest = 'unique_id',
        action = 'store_true',
        help = '''
            Replace image file names with a unique id. An ID mapping file
            will be written if this option is set.
        '''
    )
    parser.set_defaults(unique_id = False)

    flatten_img_dir_optional.add_argument('-h', '--help', action='help', help='Show this help message and exit.')


    # == merge
    merge_parser = utils_parsers.add_parser(
        'merge',
        help = '''
            Merge multiple datasets into a single one.
        ''',
        description = '''
            Merge multiple datasets into a single one.
            All input datasets must be of the same annotation type (COCO or PVOC).
            To merge two COCO datasets A and B into C, the merge command
            might be called like this:
            ginjinn utils merge -t COCO -i A/images -i B/images -a A/annotations.json -a B/annotations.json -o C
        ''',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        add_help=False,
    )

    # required
    merge_parser_required = merge_parser.add_argument_group('required arguments')

    merge_parser_required.add_argument(
        '-o', '--out_dir',
        type = str,
        help = '''
            Ouput directory, which the merged dataset will be written to.
        ''',
        required=True,
    )

    merge_parser_required.add_argument(
        '-t', '--ann_type',
        type = str,
        help = '''
            Annotation type of the datasets.
        ''',
        choices=['COCO', 'PVOC'],
    )

    merge_parser_required.add_argument(
        '-i', '--image_dir',
        type = str,
        help = '''
            A single image directory.
            This option must be provided for each input dataset.
            See description.
        ''',
        required=True,
        nargs='+',
        action='append',
    )

    merge_parser_required.add_argument(
        '-a', '--ann_path',
        type = str,
        help = '''
            A single annotation file for COCO (JSON) or a single annotation directory for PVOC.
            This option must be provided for each input dataset.
            See description.
        ''',
        required=True,
        nargs='+',
        action='append',
    )

    # optional
    merge_parser_optional = merge_parser.add_argument_group('optional arguments')

    merge_parser_optional.add_argument(
        '-l', '--link_images',
        dest = 'link_images',
        action = 'store_true',
        help = '''
            Create hard links instead of copying images.
        '''
    )
    parser.set_defaults(link_images = False)

    merge_parser_optional.add_argument('-h', '--help', action='help', help='Show this help message and exit.')


    # == sliding_window
    sliding_window_parser = utils_parsers.add_parser(
        'sliding_window',
        help = '''
            Crop images and corresponding annotation into sliding windows.
        ''',
        description = '''
            Crop images and corresponding annotation into sliding windows.
        ''',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    # required
    sliding_window_required = sliding_window_parser.add_argument_group('required arguments')

    sliding_window_required.add_argument(
        '-o', '--out_dir',
        type = str,
        help = '''
            Path to directory, which the sliding-window cropped dataset should be written to.
        ''',
        required=True,
    )
    sliding_window_required.add_argument(
        '-a', '--ann_path',
        type = str,
        help = '''
            Path to the JSON annotation file for COCO annotations or
            path to a directory containing XML annotations for PVOC annotations.
        ''',
        required=True,
    )

    # optional
    sliding_window_optional = sliding_window_parser.add_argument_group('optional arguments')
    sliding_window_optional.add_argument(
        '-i', '--img_dir',
        type = str,
        help = '''
            Path to image directory. By default, will be inferred.
        ''',
        default = None,
    )
    sliding_window_optional.add_argument(
        '-t', '--ann_type',
        type = str,
        help = '''
            Annotation type. If "auto", will be inferred.
        ''',
        choices = ['auto', 'COCO', 'PVOC'],
        default = 'auto',
    )
    sliding_window_optional.add_argument(
        '-s', '--window_size',
        type = int,
        nargs = '+',
        help = '''
            Sliding window size in pixel.
            If one argument is passed, quadratic windows of window_size will be generated.
            If two arguments are passed, they are interpreted as window width and height, respectively.

            "-s 500", for example, crops sliding windows of size 500*500 (w*h), while "-s 500 300" crops 
            windows of size 500*300.
        ''',
        default=[1000],
    )
    sliding_window_optional.add_argument(
        '-p', '--overlap',
        type = int,
        nargs = '+',
        help = '''
            Overlap between sliding windows.
            If one argument is passed, the same overlap is used in horizontal and vertical direction.
            If two arguments are passed, they are interpreted as overlap in horizontal and
            vertical, respectively.
        ''',
        default=[200],
    )
    sliding_window_optional.add_argument(
        '-k', '--task',
        choices = [
            'instance-segmentation', 'bbox-detection'
        ],
        help = '''
            Task, which the dataset will be used for. Only applies to COCO
            datasets.
        ''',
        default = 'instance-segmentation',
    )
    sliding_window_optional.add_argument(
        '-m', '--img_id',
        type = int,
        help = '''
            Starting image ID for newly generated image annotations.
        ''',
        default=1,
    )
    sliding_window_optional.add_argument(
        '-b', '--obj_id',
        type = int,
        help = '''
            Starting object ID for newly generated object annotations.
        ''',
        default=1,
    )
    sliding_window_optional.add_argument(
        '-r', '--remove_empty',
        dest = 'remove_empty',
        action = 'store_true',
        help = '''
            If this flag is set, cropped images without object annotation will
            not be saved.
        '''
    )
    parser.set_defaults(remove_empty = False)
    sliding_window_optional.add_argument(
        '-c', '--remove_incomplete',
        dest = 'remove_incomplete',
        action = 'store_true',
        help = '''
            If this flag is set, object annotations that are touched (trimmed)
            by a sliding-window edge are removed from the corresponding sliding-window images. 
        '''
    )
    parser.set_defaults(remove_incomplete = False)

    # == sw_image
    sw_image_parser = utils_parsers.add_parser(
        'sw_image',
        help = '''
            Crop images into sliding windows.
        ''',
        description = '''
            Crop images into sliding windows.
        ''',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    # required
    sw_image_required = sw_image_parser.add_argument_group('required arguments')

    sw_image_required.add_argument(
        '-o', '--out_dir',
        type = str,
        help = '''
            Path to directory, which the sliding-window images should be written to.
        ''',
        required=True,
    )
    sw_image_required.add_argument(
        '-i', '--img_dir',
        type = str,
        help = '''
            Path to image directory. By default, will be inferred.
        ''',
        required = True,
    )

    # optional
    sw_image_optional = sw_image_parser.add_argument_group('optional arguments')
    sw_image_optional.add_argument(
        '-s', '--window_size',
        type = int,
        nargs = '+',
        help = '''
            Sliding window size in pixel.
            If one argument is passed, quadratic windows of window_size will be generated.
            If two arguments are passed, they are interpreted as window width and height, respectively.

            "-s 500", for example, crops sliding windows of size 500*500 (w*h), while "-s 500 300" crops 
            windows of size 500*300.
        ''',
        default=[1000],
    )
    sw_image_optional.add_argument(
        '-p', '--overlap',
        type = int,
        nargs = '+',
        help = '''
            Overlap between sliding windows.
            If one argument is passed, the same overlap is used in horizontal and vertical direction.
            If two arguments are passed, they are interpreted as overlap in horizontal and
            vertical, respectively.
        ''',
        default=[200],
    )

    # == sw_split
    sw_split_parser = utils_parsers.add_parser(
        'sw_split',
        help = '''
            Crop train-test-val-split (ginjinn split) images and corresponding annotations
            into sliding windows.
        ''',
        description = '''
            Crop train-test-val-split (ginjinn split) images and corresponding annotations
            into sliding windows.
        ''',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    # required
    sw_split_required = sw_split_parser.add_argument_group('required arguments')

    sw_split_required.add_argument(
        '-o', '--out_dir',
        type = str,
        help = '''
            Path to directory, which the sliding-window cropped datasets should be written to.
        ''',
        required=True,
    )
    sw_split_required.add_argument(
        '-i', '--split_dir',
        type = str,
        help = '''
            Path to directory generated by ginjinn split.
        ''',
        required=True,
    )

    # optional
    sw_split_optional = sw_split_parser.add_argument_group('optional arguments')
    sw_split_optional.add_argument(
        '-t', '--ann_type',
        type = str,
        help = '''
            Annotation type. If 'auto', will be inferred.
        ''',
        choices = ['auto', 'COCO', 'PVOC'],
        default = 'auto',
    )
    sw_split_optional.add_argument(
        '-s', '--window_size',
        type = int,
        nargs = '+',
        help = '''
            Sliding window size in pixel.
            If one argument is passed, quadratic windows of window_size will be generated.
            If two arguments are passed, they are interpreted as window width and height, respectively.

            "-s 500", for example, crops sliding windows of size 500*500 (w*h), while "-s 500 300" crops 
            windows of size 500*300.
        ''',
        default=[1000],
    )
    sw_split_optional.add_argument(
        '-p', '--overlap',
        type = int,
        nargs = '+',
        help = '''
            Overlap between sliding windows in pixel.
            If one argument is passed, the same overlap is used in horizontal and vertical direction.
            If two arguments are passed, they are interpreted as overlap in horizontal and
            vertical, respectively.
        ''',
        default=[0.5],
    )
    sw_split_optional.add_argument(
        '-k', '--task',
        choices = [
            'instance-segmentation', 'bbox-detection'
        ],
        help = '''
            Task, which the dataset will be used for. Only applies to COCO
            datasets.
        ''',
        default = 'instance-segmentation',
    )
    sw_split_optional.add_argument(
        '-m', '--img_id',
        type = int,
        help = '''
            Starting image ID for newly generated image annotations.
        ''',
        default=1,
    )
    sw_split_optional.add_argument(
        '-b', '--obj_id',
        type = int,
        help = '''
            Starting object ID for newly generated object annotations.
        ''',
        default=1,
    )
    sw_split_optional.add_argument(
        '-r', '--remove_empty',
        dest = 'remove_empty',
        action = 'store_true',
        help = '''
            If this flag is set, cropped images without object annotation will
            not be saved.
        '''
    )
    parser.set_defaults(remove_empty = False)
    sw_split_optional.add_argument(
        '-c', '--remove_incomplete',
        dest = 'remove_incomplete',
        action = 'store_true',
        help = '''
            If this flag is set, object annotations that are touched (trimmed)
            by a sliding-window edge are removed from the corresponding sliding-window images. 
        '''
    )
    parser.set_defaults(remove_incomplete = False)

    # == sw_merge
    sw_merge_parser = utils_parsers.add_parser(
        'sw_merge',
        help = '''
            <EXPERIMENTAL> Merge sliding-window cropped images and annotations.
            Objects will be merged only if they satisfy ALL three thresholds.
        ''',
        description = '''
            <EXPERIMENTAL> Merge sliding-window cropped images and annotations.
            Objects will be merged only if they satisfy ALL three thresholds.
        ''',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    # required
    sw_merge_required = sw_merge_parser.add_argument_group('required arguments')
    sw_merge_required.add_argument(
        '-o', '--out_dir',
        type = str,
        help = '''
            Output directory. Will be created if it does not exist.
        ''',
        required=True,
    )
    sw_merge_required.add_argument(
        '-i', '--image_dir',
        type = str,
        help = '''
            Path to directory containing the sliding-window cropped images.
        ''',
        required=True,
    )
    sw_merge_required.add_argument(
        '-a', '--ann_path',
        type = str,
        help = '''
            Path to the JSON annotation file.
        ''',
        required=True,
    )
    sw_merge_required.add_argument(
        '-t', '--task',
        type = str,
        choices = [
            'instance-segmentation', 'bbox-detection'
        ],
        help = '''
            Task, which the dataset will be used for.
        ''',
        required = True,
    )

    # optional
    sw_merge_optional = sw_merge_parser.add_argument_group('optional arguments')
    sw_merge_optional.add_argument(
        '-c', '--intersection_threshold',
        type = int,
        help = '''
            Absolute intersection threshold for merging in pixel.
        ''',
        default=0,
    )
    sw_merge_optional.add_argument(
        '-u', '--iou_threshold',
        type = float,
        help = '''
            Intersection over union threshold for merging in pixel.
        ''',
        default=0.5,
    )
    sw_merge_optional.add_argument(
        '-s', '--ios_threshold',
        type = float,
        help = '''
            Intersection over smaller object threshold for merging in pixel.
        ''',
        default=0.8,
    )


    # == visualize
    visualize_parser = utils_parsers.add_parser(
        'visualize',
        help = '''
            Visualize object annotations on images.
        ''',
        description = '''
            Visualize object annotations on images.
        ''',
        aliases=['vis'],
    )

    # required
    visualize_parser_required = visualize_parser.add_argument_group('required arguments')
    visualize_parser_required.add_argument(
        '-o', '--out_dir',
        type = str,
        help = '''
            Directory the visualizations should be written to.
        ''',
        required=True,
    )
    visualize_parser_required.add_argument(
        '-a', '--ann_path',
        type = str,
        help = '''
            Path to COCO annotation file (JSON) or PVCO annotation directory.
        ''',
        required=True,
    )
    visualize_parser_required.add_argument(
        '-v', '--vis_type',
        type = str,
        help = '''
            Visualization type. Either "bbox" for bounding-boxes or "segmentation"
            for segmentation masks. For PVOC, only "bbox" is allowed.
        ''',
        choices = ['segmentation', 'bbox'],
        required=True,
    )

    visualize_parser_optional = visualize_parser.add_argument_group('optional arguments')
    visualize_parser_optional.add_argument(
        '-i', '--img_dir',
        type = str,
        help = '''
            Directory containing (potentially a subset) of the annotated images.
            By default, will be inferred.
        ''',
        default = None,
    )
    visualize_parser_optional.add_argument(
        '-t', '--ann_type',
        type = str,
        help = '''
            Annotation type. If "auto", will be inferred.
        ''',
        choices = ['auto', 'COCO', 'PVOC'],
        default = 'auto'
    )

    # == other utils
    # ...

    return parser

# Note: It is a deliberate decision not to subclass argparse.ArgumentParser.
#       It might be preferable to work with composition instead of inheritance,
#       since it might be desirable to include postprocessing steps after argparse
#       parsing.
class GinjinnArgumentParser():
    '''GinjinnArgumentParser

    Class for setting up and handling commandline arguments.
    '''

    _description = '''
        GinJinn is a toolbox for simplifying the setup, training, evaluation of object detection models.
        In addition, it provides data pre- and postprocessing features to facilitate the construction of
        custom object detection pipelines.
    '''

    def __init__(self):
        self.parser = argparse.ArgumentParser(
            description=self._description,
            add_help=False
        )
        self.parser.add_argument(
            '-d', '--debug',
            help='Run in debug mode.',
            action='store_true',
        )
        self.parser.add_argument(
            '-h', '--help',
            action='help',
            help='Show this help message and exit.',
        )

        self._subparsers = self.parser.add_subparsers(
            dest='subcommand',
            help='GinJinn subcommands.'
        )
        self._init_subparsers()

    def parse_args(self, args=None, namespace=None):
        '''parse_args
        Parses the commandline arguments and returns them in argparse
        format.

        Parameters
        ----------
        args
            List of strings to parse. If None, the strings are taken from sys.argv.
        namespace
            An object to take the attributes. The default is a new empty argparse Namespace object.

        Returns
        -------
        args
            Parsed argparse arguments
        '''

        return self.parser.parse_args(args=args, namespace=namespace)

    def _init_subparsers(self):
        '''_init_subparsers

        Initilialize parsers for GinJinn subcommands.
        '''

        _setup_evaluate_parser(self._subparsers)
        _setup_info_parser(self._subparsers)
        _setup_new_parser(self._subparsers)
        _setup_predict_parser(self._subparsers)
        _setup_simulate_parser(self._subparsers)
        _setup_split_parser(self._subparsers)
        _setup_train_parser(self._subparsers)
        _setup_utils_parser(self._subparsers)
